#!/usr/bin/env python3
"""
Foomuuri TUI - Simple ncurses interface for Foomuuri firewall
Requirements: pip install windows-curses (Windows) or use system ncurses (Linux)
Usage: sudo python3 foomuuri-tui.py
"""

import curses
import os
import sys
import subprocess
from pathlib import Path

CONFIG_DIR = "/etc/foomuuri"
COMMON_SERVICES = ["ssh", "http", "https", "smtp", "pop3", "imap", "dns", "ping", "dhcp-client"]

class FoomuuriConfig:
    def __init__(self):
        self.zones = []  # [{"name": "wan", "interface": "eth0"}]
        self.rules = []  # [{"from": "wan", "to": "dmz1", "services": "http https", "action": "accept"}]
        self.nat_rules = []  # [{"from": "wan", "to": "dmz1", "type": "dnat", "dport": "80", "target": "192.168.1.10:80"}]
        
    def load_config(self):
        """Load existing foomuuri configuration"""
        self.zones = []
        self.rules = []
        self.nat_rules = []
        
        # Load zones - simplified parsing
        zones_file = Path(CONFIG_DIR) / "zones.conf"
        if zones_file.exists():
            with open(zones_file, 'r') as f:
                in_zone_block = False
                for line in f:
                    line = line.strip()
                    if line.startswith("zone {"):
                        in_zone_block = True
                    elif line == "}":
                        in_zone_block = False
                    elif in_zone_block and line and not line.startswith("#"):
                        parts = line.split()
                        if len(parts) >= 1:
                            zone = {"name": parts[0], "interface": parts[1] if len(parts) > 1 else ""}
                            self.zones.append(zone)
        
        # Add default localhost if no zones
        if not self.zones:
            self.zones.append({"name": "localhost", "interface": "lo"})
            
        # Load rules - simplified
        rules_file = Path(CONFIG_DIR) / "rules.conf"
        if rules_file.exists():
            with open(rules_file, 'r') as f:
                current_rule = None
                for line in f:
                    line = line.strip()
                    if "-" in line and line.endswith("{"):
                        # New rule block: "wan-dmz1 {"
                        rule_name = line.replace(" {", "")
                        from_zone, to_zone = rule_name.split("-", 1)
                        current_rule = {"from": from_zone, "to": to_zone, "services": "", "action": ""}
                    elif current_rule and line and not line.startswith("#") and line != "}":
                        if line in ["accept", "drop", "reject"]:
                            current_rule["action"] = line
                        else:
                            current_rule["services"] = line
                    elif line == "}" and current_rule:
                        if current_rule["action"]:  # Only add complete rules
                            self.rules.append(current_rule)
                        current_rule = None
                        
    def save_config(self):
        """Save configuration to foomuuri files"""
        os.makedirs(CONFIG_DIR, exist_ok=True)
        
        # Save zones.conf
        with open(f"{CONFIG_DIR}/zones.conf", 'w') as f:
            f.write("# Generated by Foomuuri TUI\nzone {\n")
            for zone in self.zones:
                if zone["interface"]:
                    f.write(f"    {zone['name']} {zone['interface']}\n")
                else:
                    f.write(f"    {zone['name']}\n")
            f.write("}\n")
            
        # Save rules.conf
        if self.rules:
            with open(f"{CONFIG_DIR}/rules.conf", 'w') as f:
                f.write("# Generated by Foomuuri TUI\n")
                for rule in self.rules:
                    f.write(f"{rule['from']}-{rule['to']} {{\n")
                    f.write(f"    {rule['services']}\n")
                    f.write(f"    {rule['action']}\n")
                    f.write("}\n\n")
                    
        # Save nat.conf
        if self.nat_rules:
            with open(f"{CONFIG_DIR}/nat.conf", 'w') as f:
                f.write("# Generated by Foomuuri TUI\n")
                for nat in self.nat_rules:
                    f.write(f"{nat['from']}-{nat['to']} {{\n")
                    if nat['type'] == 'dnat':
                        f.write(f"    dnat tcp dport {nat['dport']} to {nat['target']}\n")
                    elif nat['type'] == 'masquerade':
                        f.write("    masquerade\n")
                    f.write("}\n\n")

class FoomuuriTUI:
    def __init__(self):
        self.config = FoomuuriConfig()
        self.current_menu = "main"
        self.selected_item = 0
        
    def run(self):
        """Main TUI loop"""
        curses.wrapper(self._main_loop)
        
    def _main_loop(self, stdscr):
        """Main curses loop"""
        self.stdscr = stdscr
        curses.curs_set(0)  # Hide cursor
        
        # Colors
        if curses.has_colors():
            curses.start_color()
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)   # Title
            curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_WHITE)  # Selected
            curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Success
            curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)    # Error
            
        self.config.load_config()
        
        while True:
            try:
                if self.current_menu == "main":
                    action = self._show_main_menu()
                elif self.current_menu == "zones":
                    action = self._show_zones_menu()
                elif self.current_menu == "rules":
                    action = self._show_rules_menu()
                elif self.current_menu == "nat":
                    action = self._show_nat_menu()
                    
                if action == "quit":
                    break
                elif action:
                    self._handle_action(action)
                    
            except KeyboardInterrupt:
                break
                
    def _show_main_menu(self):
        """Display main menu"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        # Title
        title = "╔═══════════════════════════════╗"
        self.stdscr.addstr(1, (w - len(title)) // 2, title, curses.color_pair(1))
        title = "║      Foomuuri TUI v2.0        ║"
        self.stdscr.addstr(2, (w - len(title)) // 2, title, curses.color_pair(1))
        title = "╚═══════════════════════════════╝"
        self.stdscr.addstr(3, (w - len(title)) // 2, title, curses.color_pair(1))
        
        # Menu options
        options = [
            f"1. Zone Management ({len(self.config.zones)} zones)",
            f"2. Rules Configuration ({len(self.config.rules)} rules)",
            f"3. NAT Configuration ({len(self.config.nat_rules)} rules)",
            "4. Save Configuration",
            "5. Apply & Reload",
            "Q. Quit"
        ]
        
        for i, option in enumerate(options):
            self.stdscr.addstr(6 + i, 10, option)
            
        self.stdscr.addstr(h - 3, 2, f"Config: {CONFIG_DIR}")
        self.stdscr.addstr(h - 2, 2, "Navigation: 1-5, Q=Quit")
        
        self.stdscr.refresh()
        key = self.stdscr.getch()
        
        if key == ord('1'):
            self.current_menu = "zones"
            self.selected_item = 0
        elif key == ord('2'):
            self.current_menu = "rules" 
            self.selected_item = 0
        elif key == ord('3'):
            self.current_menu = "nat"
            self.selected_item = 0
        elif key == ord('4'):
            self.config.save_config()
            self._show_message("Configuration saved!", color=3)
        elif key == ord('5'):
            return "apply"
        elif key in [ord('q'), ord('Q')]:
            return "quit"
            
    def _show_zones_menu(self):
        """Display zones management"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        self.stdscr.addstr(1, 2, "Zone Management", curses.color_pair(1) | curses.A_BOLD)
        self.stdscr.addstr(3, 2, "Zone Name        Interface")
        self.stdscr.addstr(4, 2, "─" * 30)
        
        # List zones
        for i, zone in enumerate(self.config.zones):
            line = f"{zone['name']:<15} {zone['interface']}"
            attr = curses.color_pair(2) | curses.A_BOLD if i == self.selected_item else 0
            self.stdscr.addstr(5 + i, 2, line, attr)
            
        self.stdscr.addstr(h - 4, 2, "Commands:")
        self.stdscr.addstr(h - 3, 2, "A=Add, E=Edit, D=Delete, ↑↓=Navigate, B=Back")
        self.stdscr.addstr(h - 2, 2, f"Selected: {self.selected_item + 1}/{len(self.config.zones)}")
        
        self.stdscr.refresh()
        key = self.stdscr.getch()
        
        if key in [ord('a'), ord('A')]:
            return "add_zone"
        elif key in [ord('e'), ord('E')] and self.config.zones:
            return "edit_zone"
        elif key in [ord('d'), ord('D')] and self.config.zones:
            return "delete_zone"
        elif key == curses.KEY_UP and self.selected_item > 0:
            self.selected_item -= 1
        elif key == curses.KEY_DOWN and self.selected_item < len(self.config.zones) - 1:
            self.selected_item += 1
        elif key in [ord('b'), ord('B')]:
            self.current_menu = "main"
            
    def _show_rules_menu(self):
        """Display rules configuration"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        self.stdscr.addstr(1, 2, "Rules Configuration", curses.color_pair(1) | curses.A_BOLD)
        self.stdscr.addstr(3, 2, "From → To          Services           Action")
        self.stdscr.addstr(4, 2, "─" * 50)
        
        for i, rule in enumerate(self.config.rules):
            direction = f"{rule['from']} → {rule['to']}"
            line = f"{direction:<17} {rule['services']:<15} {rule['action']}"
            
            attr = curses.color_pair(2) | curses.A_BOLD if i == self.selected_item else 0
            if rule['action'] == 'accept':
                attr |= curses.color_pair(3)
            elif rule['action'] in ['drop', 'reject']:
                attr |= curses.color_pair(4)
                
            self.stdscr.addstr(5 + i, 2, line, attr)
            
        self.stdscr.addstr(h - 4, 2, "Commands:")
        self.stdscr.addstr(h - 3, 2, "A=Add Rule, E=Edit, D=Delete, ↑↓=Navigate, B=Back")
        
        self.stdscr.refresh()
        key = self.stdscr.getch()
        
        if key in [ord('a'), ord('A')]:
            return "add_rule"
        elif key in [ord('e'), ord('E')] and self.config.rules:
            return "edit_rule"
        elif key in [ord('d'), ord('D')] and self.config.rules:
            return "delete_rule"
        elif key == curses.KEY_UP and self.selected_item > 0:
            self.selected_item -= 1
        elif key == curses.KEY_DOWN and self.selected_item < len(self.config.rules) - 1:
            self.selected_item += 1
        elif key in [ord('b'), ord('B')]:
            self.current_menu = "main"
            
    def _show_nat_menu(self):
        """Display NAT configuration"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        self.stdscr.addstr(1, 2, "NAT Configuration", curses.color_pair(1) | curses.A_BOLD)
        self.stdscr.addstr(3, 2, "Direction          Type         Target")
        self.stdscr.addstr(4, 2, "─" * 40)
        
        for i, nat in enumerate(self.config.nat_rules):
            direction = f"{nat['from']} → {nat['to']}"
            target = nat.get('target', 'auto') if nat['type'] == 'dnat' else 'auto'
            line = f"{direction:<17} {nat['type']:<12} {target}"
            
            attr = curses.color_pair(2) | curses.A_BOLD if i == self.selected_item else 0
            self.stdscr.addstr(5 + i, 2, line, attr)
            
        self.stdscr.addstr(h - 4, 2, "Commands:")
        self.stdscr.addstr(h - 3, 2, "A=Add NAT, D=Delete, ↑↓=Navigate, B=Back")
        
        self.stdscr.refresh()
        key = self.stdscr.getch()
        
        if key in [ord('a'), ord('A')]:
            return "add_nat"
        elif key in [ord('d'), ord('D')] and self.config.nat_rules:
            return "delete_nat"
        elif key == curses.KEY_UP and self.selected_item > 0:
            self.selected_item -= 1
        elif key == curses.KEY_DOWN and self.selected_item < len(self.config.nat_rules) - 1:
            self.selected_item += 1
        elif key in [ord('b'), ord('B')]:
            self.current_menu = "main"
            
    def _handle_action(self, action):
        """Handle menu actions"""
        if action == "add_zone":
            self._add_zone()
        elif action == "edit_zone":
            self._edit_zone()
        elif action == "delete_zone":
            self._delete_zone()
        elif action == "add_rule":
            self._add_rule()
        elif action == "edit_rule":
            self._edit_rule()
        elif action == "delete_rule":
            self._delete_rule()
        elif action == "add_nat":
            self._add_nat()
        elif action == "delete_nat":
            self._delete_nat()
        elif action == "apply":
            self._apply_config()
            
    def _add_zone(self):
        """Add new zone"""
        name = self._get_input("Zone name: ")
        if name:
            interface = self._get_input("Interface (optional): ")
            self.config.zones.append({"name": name, "interface": interface or ""})
            self._show_message("Zone added successfully!", color=3)
            
    def _edit_zone(self):
        """Edit selected zone"""
        zone = self.config.zones[self.selected_item]
        new_interface = self._get_input(f"Interface for {zone['name']} (current: {zone['interface']}): ")
        if new_interface is not None:  # Allow empty string
            zone['interface'] = new_interface
            self._show_message("Zone updated!", color=3)
            
    def _delete_zone(self):
        """Delete selected zone"""
        if len(self.config.zones) <= 1:
            self._show_message("Cannot delete last zone!", color=4)
            return
            
        zone = self.config.zones[self.selected_item]
        if self._confirm(f"Delete zone '{zone['name']}'?"):
            del self.config.zones[self.selected_item]
            if self.selected_item >= len(self.config.zones):
                self.selected_item = len(self.config.zones) - 1
            self._show_message("Zone deleted!", color=3)
            
    def _add_rule(self):
        """Add new firewall rule"""
        if len(self.config.zones) < 2:
            self._show_message("Need at least 2 zones!", color=4)
            return
            
        zone_names = [z['name'] for z in self.config.zones]
        
        from_zone = self._select_from_list("From zone:", zone_names)
        if not from_zone:
            return
            
        to_zone = self._select_from_list("To zone:", zone_names)
        if not to_zone:
            return
            
        service = self._select_from_list("Service:", COMMON_SERVICES)
        if not service:
            return
            
        action = self._select_from_list("Action:", ["accept", "drop", "reject"])
        if not action:
            return
            
        rule = {
            "from": from_zone,
            "to": to_zone,
            "services": service,
            "action": action
        }
        self.config.rules.append(rule)
        self._show_message("Rule added!", color=3)
        
    def _edit_rule(self):
        """Edit selected rule"""
        rule = self.config.rules[self.selected_item]
        new_action = self._select_from_list("New action:", ["accept", "drop", "reject"])
        if new_action:
            rule['action'] = new_action
            self._show_message("Rule updated!", color=3)
            
    def _delete_rule(self):
        """Delete selected rule"""
        rule = self.config.rules[self.selected_item]
        if self._confirm(f"Delete rule {rule['from']} → {rule['to']}?"):
            del self.config.rules[self.selected_item]
            if self.selected_item >= len(self.config.rules):
                self.selected_item = len(self.config.rules) - 1
            self._show_message("Rule deleted!", color=3)
            
    def _add_nat(self):
        """Add NAT rule"""
        if len(self.config.zones) < 2:
            self._show_message("Need at least 2 zones!", color=4)
            return
            
        zone_names = [z['name'] for z in self.config.zones]
        
        from_zone = self._select_from_list("From zone:", zone_names)
        if not from_zone:
            return
            
        to_zone = self._select_from_list("To zone:", zone_names)
        if not to_zone:
            return
            
        nat_type = self._select_from_list("NAT type:", ["dnat", "masquerade"])
        if not nat_type:
            return
            
        nat_rule = {"from": from_zone, "to": to_zone, "type": nat_type}
        
        if nat_type == "dnat":
            dport = self._get_input("Source port: ")
            target = self._get_input("Target (IP:port): ")
            if dport and target:
                nat_rule.update({"dport": dport, "target": target})
            else:
                return
                
        self.config.nat_rules.append(nat_rule)
        self._show_message("NAT rule added!", color=3)
        
    def _delete_nat(self):
        """Delete selected NAT rule"""
        nat = self.config.nat_rules[self.selected_item]
        if self._confirm(f"Delete NAT rule {nat['from']} → {nat['to']}?"):
            del self.config.nat_rules[self.selected_item]
            if self.selected_item >= len(self.config.nat_rules):
                self.selected_item = len(self.config.nat_rules) - 1
            self._show_message("NAT rule deleted!", color=3)
            
    def _apply_config(self):
        """Save and apply configuration"""
        self.config.save_config()
        self._show_message("Applying configuration...", color=3)
        
        try:
            result = subprocess.run(["foomuuri", "reload"], 
                                  capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                self._show_message("Configuration applied successfully!", color=3)
            else:
                self._show_message(f"Error: {result.stderr}", color=4)
        except subprocess.TimeoutExpired:
            self._show_message("Timeout applying config!", color=4)
        except FileNotFoundError:
            self._show_message("Foomuuri not found! Install first.", color=4)
            
    def _get_input(self, prompt):
        """Get text input from user"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        self.stdscr.addstr(h // 2 - 1, 2, prompt)
        self.stdscr.addstr(h // 2 + 1, 2, "Enter text (ESC to cancel):")
        
        curses.echo()
        curses.curs_set(1)
        
        try:
            self.stdscr.refresh()
            text = self.stdscr.getstr(h // 2 + 2, 2, 50).decode('utf-8')
            return text
        except KeyboardInterrupt:
            return None
        finally:
            curses.noecho()
            curses.curs_set(0)
            
    def _select_from_list(self, prompt, options):
        """Select item from list"""
        selected = 0
        
        while True:
            self.stdscr.clear()
            h, w = self.stdscr.getmaxyx()
            
            self.stdscr.addstr(2, 2, prompt, curses.A_BOLD)
            self.stdscr.addstr(4, 2, "↑↓=Navigate, Enter=Select, ESC=Cancel")
            
            for i, option in enumerate(options):
                attr = curses.color_pair(2) | curses.A_BOLD if i == selected else 0
                self.stdscr.addstr(6 + i, 4, option, attr)
                
            self.stdscr.refresh()
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP and selected > 0:
                selected -= 1
            elif key == curses.KEY_DOWN and selected < len(options) - 1:
                selected += 1
            elif key == ord('\n'):
                return options[selected]
            elif key == 27:  # ESC
                return None
                
    def _confirm(self, message):
        """Show confirmation dialog"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        self.stdscr.addstr(h // 2, (w - len(message)) // 2, message)
        self.stdscr.addstr(h // 2 + 2, (w - 15) // 2, "(y/N): ")
        self.stdscr.refresh()
        
        key = self.stdscr.getch()
        return key in [ord('y'), ord('Y')]
        
    def _show_message(self, message, color=0):
        """Show message and wait for key"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        self.stdscr.addstr(h // 2, (w - len(message)) // 2, message, curses.color_pair(color))
        self.stdscr.addstr(h // 2 + 2, (w - 20) // 2, "Press any key...")
        self.stdscr.refresh()
        self.stdscr.getch()

def main():
    if os.geteuid() != 0:
        print("This program must be run as root to modify firewall configuration.")
        sys.exit(1)
        
    tui = FoomuuriTUI()
    tui.run()

if __name__ == "__main__":
    main()
